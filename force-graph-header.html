<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Force Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #e8e8e8;
            color: #2a2a2a;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 300px;
            transition: height 0.3s ease;
        }

        #container.fullscreen {
            height: 100vh;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            cursor: crosshair;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
        }

        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }

        button {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        button:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        button.active {
            background: #4a9eff;
            color: white;
            border-color: #4a9eff;
        }

        #fullscreen-toggle, #toggle-controls {
            position: absolute;
            top: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        #fullscreen-toggle {
            right: 10px;
        }

        #toggle-controls {
            left: 300px;
        }

        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 10px;
            color: #555;
            max-width: 300px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        #controls.hidden {
            display: none;
        }

        .preset-info {
            font-size: 10px;
            color: #666;
            margin: 10px 0;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            border-left: 3px solid #4a9eff;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <button id="toggle-controls">Hide Controls</button>
        <button id="fullscreen-toggle">‚õ∂ Fullscreen</button>

        <div id="controls">
            <h3>‚ö° Force Graph Playground</h3>

            <div class="preset-buttons">
                <button class="preset" data-preset="rain">üåß Rain</button>
                <button class="preset" data-preset="honey">üçØ Honey</button>
                <button class="preset" data-preset="chaos">üéÜ Chaos</button>
            </div>

            <div class="preset-info" id="preset-info">
                Select a preset to begin
            </div>
        </div>

        <div id="info">
            <strong>Controls:</strong><br>
            <span id="info-text">Select a preset to see controls</span>
        </div>
    </div>

    <script>
        // Setup
        const container = document.getElementById('container');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = window.innerWidth;
        let height = 300;
        canvas.width = width;
        canvas.height = height;

        // Simulation state
        let nodes = [];
        let links = [];
        let paused = false;
        let currentPreset = null;
        let mousePos = { x: width / 2, y: height / 2 };
        let dragNode = null;
        let frameCount = 0;
        let isMouseDown = false;
        let mouseButton = null;

        // Preset-specific parameters
        let presetParams = {
            rain: {
                rainRate: 3,
                waterLevel: 0,
                colors: {
                    rain: ['#5ba3d0', '#6db3e0', '#7fc3f0'],
                    water: ['#4080b0', '#5090c0', '#60a0d0']
                }
            },
            honey: {
                flowDirection: { x: 0, y: 1 },  // Default downward
                flowSpeed: 0.3,
                collisionDistance: 15,
                colors: {
                    blob: ['#d4a574', '#e0b584', '#ecc594', '#f8d5a4']
                }
            },
            chaos: {
                splitChance: 0.001,
                mergeChance: 0.002,
                colors: {
                    particle: ['#dd6666', '#66dd66', '#6666dd', '#dddd66', '#dd66dd', '#66dddd']
                }
            }
        };

        // Group definitions
        const GROUP_TYPES = {
            RAIN: 'rain',
            WATER: 'water',
            HONEY_BLOB: 'honey_blob',
            CHAOS_PARTICLE: 'chaos_particle'
        };

        // Node factory
        function createNode(type, x, y, extraProps = {}) {
            const baseNode = {
                id: Math.random().toString(36).substr(2, 9),
                type: type,
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                ...extraProps
            };

            switch(type) {
                case GROUP_TYPES.RAIN:
                    return { ...baseNode, radius: 2, mass: 0.5, color: randomFromArray(presetParams.rain.colors.rain) };
                case GROUP_TYPES.WATER:
                    return { ...baseNode, radius: 3, mass: 1, color: randomFromArray(presetParams.rain.colors.water) };
                case GROUP_TYPES.HONEY_BLOB:
                    return { ...baseNode, radius: 6, mass: 1, color: randomFromArray(presetParams.honey.colors.blob) };
                case GROUP_TYPES.CHAOS_PARTICLE:
                    return { ...baseNode, radius: 5, mass: 1, color: randomFromArray(presetParams.chaos.colors.particle), energy: Math.random() };
                default:
                    return baseNode;
            }
        }

        function randomFromArray(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // Find nearest gap in water surface for raindrop
        function findNearestGap(raindrop, waterNodes) {
            if (waterNodes.length === 0) return raindrop.x;

            // Sample positions along water level
            const samplePoints = [];
            const samples = 50;
            for (let i = 0; i < samples; i++) {
                const x = (i / samples) * width;
                samplePoints.push({ x: x, minDist: Infinity });
            }

            // Find closest water node to each sample point
            samplePoints.forEach(point => {
                waterNodes.forEach(water => {
                    const d = Math.abs(water.x - point.x);
                    if (d < point.minDist) {
                        point.minDist = d;
                    }
                });
            });

            // Find the sample point with maximum distance to water (biggest gap)
            let bestGap = samplePoints[0];
            samplePoints.forEach(point => {
                if (point.minDist > bestGap.minDist) {
                    bestGap = point;
                }
            });

            return bestGap.x;
        }

        // Preset initializers
        const presets = {
            rain: {
                init: () => {
                    nodes = [];
                    links = [];
                    presetParams.rain.waterLevel = height - 40;
                },
                update: () => {
                    frameCount++;

                    // Spawn rain drops
                    if (frameCount % Math.floor(10 / presetParams.rain.rainRate) === 0) {
                        const raindrop = createNode(GROUP_TYPES.RAIN,
                            Math.random() * width,
                            -10
                        );
                        raindrop.vy = 2 + Math.random();
                        nodes.push(raindrop);
                    }

                    const waterNodes = nodes.filter(n => n.type === GROUP_TYPES.WATER);

                    // Update nodes
                    nodes.forEach((node, i) => {
                        if (node.type === GROUP_TYPES.RAIN) {
                            // Rain falls
                            node.vy += 0.3;
                            node.y += node.vy;

                            // When approaching water level, seek nearest gap
                            if (node.y > presetParams.rain.waterLevel - 20) {
                                const targetX = findNearestGap(node, waterNodes);
                                const dx = targetX - node.x;
                                node.vx = dx * 0.1; // Steer toward gap
                            }

                            node.x += node.vx;

                            // Convert to water when hitting water level
                            if (node.y > presetParams.rain.waterLevel) {
                                node.type = GROUP_TYPES.WATER;
                                node.radius = 3 + Math.random() * 1.5; // Slight random variation
                                node.mass = 1;
                                node.color = randomFromArray(presetParams.rain.colors.water);
                                node.vx = (Math.random() - 0.5) * 0.5;
                                node.vy = 0;

                                // Link to nearest 2-3 water nodes
                                const nearbyWater = waterNodes
                                    .map(w => ({ node: w, dist: dist(node, w) }))
                                    .sort((a, b) => a.dist - b.dist)
                                    .slice(0, 3)
                                    .filter(w => w.dist < 50);

                                nearbyWater.forEach(({ node: target }) => {
                                    links.push({
                                        source: node,
                                        target,
                                        strength: 0.4,
                                        distance: 18,
                                        restLength: 18, // Fixed minimum length to reduce jitter
                                        minLength: 15
                                    });
                                });

                                // Update water level
                                const waterYs = nodes.filter(n => n.type === GROUP_TYPES.WATER).map(n => n.y);
                                if (waterYs.length > 0) {
                                    presetParams.rain.waterLevel = Math.max(
                                        height * 0.3,
                                        Math.min(...waterYs) - 10
                                    );
                                }
                            }

                            // Remove if out of bounds
                            if (node.y > height + 50) {
                                nodes.splice(i, 1);
                            }
                        } else if (node.type === GROUP_TYPES.WATER) {
                            // Update node size based on number of connections
                            const nodeLinks = links.filter(l => l.source === node || l.target === node);
                            const baseRadius = 3;
                            node.radius = baseRadius + Math.min(nodeLinks.length * 0.3, 1.5);

                            // Random shimmer movement
                            node.vx += (Math.random() - 0.5) * 0.1;
                            node.vy += (Math.random() - 0.5) * 0.1;

                            // Gravity pulls down
                            node.vy += 0.2;

                            // Spring forces from connections with minimum length enforcement
                            nodeLinks.forEach(link => {
                                const other = link.source === node ? link.target : link.source;
                                const dx = other.x - node.x;
                                const dy = other.y - node.y;
                                const d = Math.sqrt(dx * dx + dy * dy);

                                if (d > 0) {
                                    // Enforce minimum edge length
                                    const targetLength = Math.max(link.restLength, link.minLength || 15);
                                    const force = (d - targetLength) * link.strength;
                                    node.vx += (dx / d) * force * 0.15;
                                    node.vy += (dy / d) * force * 0.15;

                                    // If too close, push apart more strongly
                                    if (d < link.minLength) {
                                        const pushForce = (link.minLength - d) * 0.1;
                                        node.vx -= (dx / d) * pushForce;
                                        node.vy -= (dy / d) * pushForce;
                                    }
                                }
                            });

                            // Repulsion from other water nodes (stay close but not touching)
                            waterNodes.forEach(other => {
                                if (other !== node) {
                                    const dx = node.x - other.x;
                                    const dy = node.y - other.y;
                                    const d = Math.sqrt(dx * dx + dy * dy);

                                    if (d < 10 && d > 0) {
                                        const force = (10 - d) * 0.08;
                                        node.vx += (dx / d) * force;
                                        node.vy += (dy / d) * force;
                                    }
                                }
                            });

                            // Damping
                            node.vx *= 0.92;
                            node.vy *= 0.92;

                            // Update position
                            node.x += node.vx;
                            node.y += node.vy;

                            // Keep on screen
                            if (node.x < 5) {
                                node.x = 5;
                                node.vx *= -0.5;
                            }
                            if (node.x > width - 5) {
                                node.x = width - 5;
                                node.vx *= -0.5;
                            }
                            if (node.y > height - 5) {
                                node.y = height - 5;
                                node.vy *= -0.3;
                            }
                        }
                    });
                },
                info: 'Rain falls and seeks gaps in the water surface.<br>üñ± Wheel: Control rain rate'
            },

            honey: {
                init: () => {
                    nodes = [];
                    links = [];
                    presetParams.honey.flowDirection = { x: 0, y: 1 };

                    // Start with some honey blobs
                    for (let i = 0; i < 15; i++) {
                        nodes.push(createNode(GROUP_TYPES.HONEY_BLOB,
                            Math.random() * width,
                            Math.random() * height * 0.5
                        ));
                    }
                },
                update: () => {
                    const { flowDirection, flowSpeed, collisionDistance } = presetParams.honey;

                    nodes.forEach((node, i) => {
                        // Apply default flow direction
                        node.vx += flowDirection.x * flowSpeed * 0.1;
                        node.vy += flowDirection.y * flowSpeed * 0.1;

                        // Spring forces from connections with minimum length enforcement
                        const nodeLinks = links.filter(l => l.source === node || l.target === node);
                        nodeLinks.forEach(link => {
                            const other = link.source === node ? link.target : link.source;
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const d = Math.sqrt(dx * dx + dy * dy);

                            if (d > 0) {
                                // Enforce minimum edge length (2 * node radius)
                                const minLength = link.minLength || 12;
                                const targetLength = Math.max(link.restLength, minLength);
                                const force = (d - targetLength) * link.strength;

                                node.vx += (dx / d) * force * 0.08;
                                node.vy += (dy / d) * force * 0.08;

                                // Strong repulsion if too close
                                if (d < minLength) {
                                    const pushForce = (minLength - d) * 0.2;
                                    node.vx -= (dx / d) * pushForce;
                                    node.vy -= (dy / d) * pushForce;
                                }

                                // Increased friction - makes entire goo slide together
                                node.vx += (other.vx - node.vx) * 0.15;
                                node.vy += (other.vy - node.vy) * 0.15;
                            }
                        });

                        // Check for collisions with other blobs
                        nodes.forEach((other, j) => {
                            if (i < j) {
                                const d = dist(node, other);
                                if (d < collisionDistance) {
                                    // Create connection if not already connected
                                    const alreadyConnected = links.find(l =>
                                        (l.source === node && l.target === other) ||
                                        (l.source === other && l.target === node)
                                    );

                                    if (!alreadyConnected) {
                                        const minEdgeLength = 12; // Minimum to prevent overlap
                                        links.push({
                                            source: node,
                                            target: other,
                                            strength: 1.0,
                                            distance: collisionDistance,
                                            restLength: Math.max(collisionDistance * 0.8, minEdgeLength),
                                            minLength: minEdgeLength
                                        });
                                    }
                                }
                            }
                        });

                        // High viscosity damping
                        node.vx *= 0.85;
                        node.vy *= 0.85;

                        // Update position
                        node.x += node.vx;
                        node.y += node.vy;

                        // Wrap around edges
                        if (node.x < -20) node.x = width + 20;
                        if (node.x > width + 20) node.x = -20;
                        if (node.y < -20) node.y = height + 20;
                        if (node.y > height + 20) node.y = -20;
                    });
                },
                info: 'Honey flows and coalesces into globs.<br>üñ± Left-click: Drag | Right-click drag: Create<br>‚å®Ô∏è Arrow keys: Change flow direction'
            },

            chaos: {
                init: () => {
                    nodes = [];
                    links = [];

                    for (let i = 0; i < 25; i++) {
                        const particle = createNode(GROUP_TYPES.CHAOS_PARTICLE,
                            Math.random() * width,
                            Math.random() * height
                        );
                        particle.vx = (Math.random() - 0.5) * 4;
                        particle.vy = (Math.random() - 0.5) * 4;
                        nodes.push(particle);
                    }
                },
                update: () => {
                    nodes.forEach((node, i) => {
                        // Random force bursts
                        if (Math.random() < 0.02) {
                            node.vx += (Math.random() - 0.5) * 2;
                            node.vy += (Math.random() - 0.5) * 2;
                        }

                        // Update position
                        node.x += node.vx;
                        node.y += node.vy;

                        // Bounce off walls
                        if (node.x < node.radius || node.x > width - node.radius) {
                            node.vx *= -0.9;
                            node.x = Math.max(node.radius, Math.min(width - node.radius, node.x));
                        }
                        if (node.y < node.radius || node.y > height - node.radius) {
                            node.vy *= -0.9;
                            node.y = Math.max(node.radius, Math.min(height - node.radius, node.y));
                        }

                        // Slight drag
                        node.vx *= 0.98;
                        node.vy *= 0.98;

                        // Random splitting
                        if (Math.random() < presetParams.chaos.splitChance && nodes.length < 50) {
                            const newParticle = createNode(GROUP_TYPES.CHAOS_PARTICLE,
                                node.x + (Math.random() - 0.5) * 10,
                                node.y + (Math.random() - 0.5) * 10
                            );
                            newParticle.vx = node.vx + (Math.random() - 0.5) * 2;
                            newParticle.vy = node.vy + (Math.random() - 0.5) * 2;
                            newParticle.radius = node.radius * 0.8;
                            node.radius *= 0.8;
                            nodes.push(newParticle);
                        }

                        // Random merging
                        nodes.forEach((other, j) => {
                            if (i < j && dist(node, other) < 15 && Math.random() < presetParams.chaos.mergeChance) {
                                // Merge into first node
                                node.radius = Math.sqrt(node.radius * node.radius + other.radius * other.radius);
                                node.vx = (node.vx + other.vx) / 2;
                                node.vy = (node.vy + other.vy) / 2;
                                nodes.splice(j, 1);
                            }
                        });
                    });
                },
                info: 'Chaotic particles split and merge randomly.<br>üñ± Click: Add energy burst'
            }
        };

        // Render function
        function render() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(245, 245, 245, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw links
            ctx.lineWidth = 2;
            links.forEach(link => {
                const source = link.source;
                const target = link.target;

                ctx.strokeStyle = source.color + '60';
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius
                );
                gradient.addColorStop(0, node.color + 'dd');
                gradient.addColorStop(1, node.color + '66');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = node.color + '99';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Animation loop
        function tick() {
            if (!paused && currentPreset) {
                presets[currentPreset].update();
            }
            render();
            requestAnimationFrame(tick);
        }

        // Mouse interactions
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            isMouseDown = true;
            mouseButton = e.button;

            if (currentPreset === 'honey') {
                if (e.button === 0) {
                    // Left click - drag existing node
                    dragNode = nodes.find(node => dist(node, {x, y}) < node.radius + 5);
                }
            } else {
                // Other presets - find node to drag
                dragNode = nodes.find(node => dist(node, {x, y}) < node.radius + 5);

                // Chaos mode - add energy burst on click
                if (!dragNode && currentPreset === 'chaos' && e.button === 0) {
                    nodes.forEach(node => {
                        const d = dist(node, {x, y});
                        if (d < 80) {
                            const force = (80 - d) * 0.1;
                            const angle = Math.atan2(node.y - y, node.x - x);
                            node.vx += Math.cos(angle) * force;
                            node.vy += Math.sin(angle) * force;
                        }
                    });
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;

            if (isMouseDown && currentPreset === 'honey') {
                if (mouseButton === 2) {
                    // Right click drag - create new particles
                    if (frameCount % 3 === 0) {
                        const newNode = createNode(GROUP_TYPES.HONEY_BLOB, mousePos.x, mousePos.y);
                        newNode.vx = (Math.random() - 0.5) * 2;
                        newNode.vy = (Math.random() - 0.5) * 2;
                        nodes.push(newNode);
                    }
                } else if (mouseButton === 0 && dragNode) {
                    // Left click drag - move particle
                    dragNode.x = mousePos.x;
                    dragNode.y = mousePos.y;
                    dragNode.vx = 0;
                    dragNode.vy = 0;
                }
            } else if (dragNode && !dragNode.fixed) {
                dragNode.x = mousePos.x;
                dragNode.y = mousePos.y;
                dragNode.vx = 0;
                dragNode.vy = 0;
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragNode = null;
            isMouseDown = false;
            mouseButton = null;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            if (currentPreset === 'rain') {
                // Control rain rate
                const delta = e.deltaY > 0 ? -0.5 : 0.5;
                presetParams.rain.rainRate = Math.max(0.5, Math.min(10, presetParams.rain.rainRate + delta));
            } else if (currentPreset === 'honey') {
                // Control flow speed
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                presetParams.honey.flowSpeed = Math.max(0.1, Math.min(1, presetParams.honey.flowSpeed + delta));
            }
        });

        // Keyboard interactions
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                paused = !paused;
            }

            // Honey mode - arrow keys change flow direction
            if (currentPreset === 'honey') {
                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        presetParams.honey.flowDirection = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        presetParams.honey.flowDirection = { x: 0, y: 1 };
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        presetParams.honey.flowDirection = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        presetParams.honey.flowDirection = { x: 1, y: 0 };
                        break;
                }
            }
        });

        // Preset selection
        document.querySelectorAll('.preset').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPreset = btn.dataset.preset;
                frameCount = 0;
                presets[currentPreset].init();
                document.getElementById('preset-info').innerHTML = presets[currentPreset].info;
                document.getElementById('info-text').innerHTML = presets[currentPreset].info;
            });
        });

        // Fullscreen toggle
        document.getElementById('fullscreen-toggle').addEventListener('click', () => {
            container.classList.toggle('fullscreen');
            setTimeout(() => {
                width = window.innerWidth;
                height = container.classList.contains('fullscreen') ? window.innerHeight : 300;
                canvas.width = width;
                canvas.height = height;
                if (currentPreset) {
                    presets[currentPreset].init();
                }
            }, 50);
        });

        // Toggle controls
        document.getElementById('toggle-controls').addEventListener('click', (e) => {
            const controls = document.getElementById('controls');
            controls.classList.toggle('hidden');
            e.target.textContent = controls.classList.contains('hidden') ? 'Show Controls' : 'Hide Controls';
        });

        // Window resize
        window.addEventListener('resize', () => {
            if (!container.classList.contains('fullscreen')) {
                width = window.innerWidth;
                canvas.width = width;
                if (currentPreset) {
                    presets[currentPreset].init();
                }
            }
        });

        // Initialize with rain
        currentPreset = 'rain';
        presets.rain.init();
        document.querySelector('[data-preset="rain"]').classList.add('active');
        document.getElementById('preset-info').innerHTML = presets.rain.info;
        document.getElementById('info-text').innerHTML = presets.rain.info;
        tick();
    </script>
</body>
</html>
