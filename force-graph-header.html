<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Force Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #e8e8e8;
            color: #2a2a2a;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 300px;
            transition: height 0.3s ease;
        }

        #container.fullscreen {
            height: 100vh;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            cursor: crosshair;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
        }

        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }

        button {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        button:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        button.active {
            background: #4a9eff;
            color: white;
            border-color: #4a9eff;
        }

        #fullscreen-toggle, #toggle-controls {
            position: absolute;
            top: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        #fullscreen-toggle {
            right: 10px;
        }

        #toggle-controls {
            left: 300px;
        }

        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 10px;
            color: #555;
            max-width: 280px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        #controls.hidden {
            display: none;
        }

        .preset-info {
            font-size: 10px;
            color: #666;
            margin: 10px 0;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            border-left: 3px solid #4a9eff;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <button id="toggle-controls">Hide Controls</button>
        <button id="fullscreen-toggle">‚õ∂ Fullscreen</button>

        <div id="controls">
            <h3>‚ö° Force Graph Playground</h3>

            <div class="preset-buttons">
                <button class="preset" data-preset="rain">üåß Rain</button>
                <button class="preset" data-preset="honey">üçØ Honey</button>
                <button class="preset" data-preset="galaxy">üåå Galaxy</button>
                <button class="preset" data-preset="chaos">üéÜ Chaos</button>
            </div>

            <div class="preset-info" id="preset-info">
                Select a preset to begin
            </div>
        </div>

        <div id="info">
            <strong>Controls:</strong><br>
            <span id="info-text">Select a preset to see controls</span>
        </div>
    </div>

    <script>
        // Setup
        const container = document.getElementById('container');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = window.innerWidth;
        let height = 300;
        canvas.width = width;
        canvas.height = height;

        // Simulation state
        let nodes = [];
        let links = [];
        let paused = false;
        let currentPreset = null;
        let mousePos = { x: width / 2, y: height / 2 };
        let dragNode = null;
        let frameCount = 0;

        // Preset-specific parameters
        let presetParams = {
            rain: {
                rainRate: 3,
                waterLevel: 0,
                colors: {
                    rain: ['#5ba3d0', '#6db3e0', '#7fc3f0'],
                    water: ['#4080b0', '#5090c0', '#60a0d0'],
                    boat: ['#c07050', '#d08060', '#e09070']
                }
            },
            honey: {
                viscosity: 0.9,
                mergeDistance: 30,
                colors: {
                    blob: ['#d4a574', '#e0b584', '#ecc594', '#f8d5a4']
                }
            },
            galaxy: {
                orbitalStrength: 0.02,
                colors: {
                    center: ['#8866dd', '#9977ee'],
                    orbiter: ['#6688cc', '#7799dd', '#88aaee']
                }
            },
            chaos: {
                splitChance: 0.001,
                mergeChance: 0.002,
                colors: {
                    particle: ['#dd6666', '#66dd66', '#6666dd', '#dddd66', '#dd66dd', '#66dddd']
                }
            }
        };

        // Group definitions
        const GROUP_TYPES = {
            RAIN: 'rain',
            WATER: 'water',
            BOAT: 'boat',
            HONEY_BLOB: 'honey_blob',
            GALAXY_CENTER: 'galaxy_center',
            GALAXY_ORBITER: 'galaxy_orbiter',
            CHAOS_PARTICLE: 'chaos_particle'
        };

        // Node factory
        function createNode(type, x, y, extraProps = {}) {
            const baseNode = {
                id: Math.random().toString(36).substr(2, 9),
                type: type,
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                ...extraProps
            };

            switch(type) {
                case GROUP_TYPES.RAIN:
                    return { ...baseNode, radius: 2, mass: 0.5, color: randomFromArray(presetParams.rain.colors.rain) };
                case GROUP_TYPES.WATER:
                    return { ...baseNode, radius: 4, mass: 1, color: randomFromArray(presetParams.rain.colors.water) };
                case GROUP_TYPES.BOAT:
                    return { ...baseNode, radius: 5, mass: 2, color: randomFromArray(presetParams.rain.colors.boat) };
                case GROUP_TYPES.HONEY_BLOB:
                    return { ...baseNode, radius: 6, mass: 1.5, color: randomFromArray(presetParams.honey.colors.blob), viscous: true };
                case GROUP_TYPES.GALAXY_CENTER:
                    return { ...baseNode, radius: 15, mass: 100, color: randomFromArray(presetParams.galaxy.colors.center), fixed: true };
                case GROUP_TYPES.GALAXY_ORBITER:
                    return { ...baseNode, radius: 3, mass: 0.5, color: randomFromArray(presetParams.galaxy.colors.orbiter) };
                case GROUP_TYPES.CHAOS_PARTICLE:
                    return { ...baseNode, radius: 5, mass: 1, color: randomFromArray(presetParams.chaos.colors.particle), energy: Math.random() };
                default:
                    return baseNode;
            }
        }

        function randomFromArray(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Preset initializers
        const presets = {
            rain: {
                init: () => {
                    nodes = [];
                    links = [];

                    // Create boat (connected nodes that float)
                    const boatX = width / 2;
                    const boatY = height * 0.4;
                    const boat = [
                        createNode(GROUP_TYPES.BOAT, boatX - 20, boatY),
                        createNode(GROUP_TYPES.BOAT, boatX + 20, boatY),
                        createNode(GROUP_TYPES.BOAT, boatX, boatY - 15),
                        createNode(GROUP_TYPES.BOAT, boatX, boatY + 15)
                    ];
                    nodes.push(...boat);

                    // Connect boat nodes
                    links.push(
                        { source: boat[0], target: boat[1], strength: 1, distance: 40 },
                        { source: boat[0], target: boat[2], strength: 1, distance: 30 },
                        { source: boat[1], target: boat[2], strength: 1, distance: 30 },
                        { source: boat[0], target: boat[3], strength: 1, distance: 30 },
                        { source: boat[1], target: boat[3], strength: 1, distance: 30 }
                    );

                    // Initial water nodes
                    for (let i = 0; i < 20; i++) {
                        const waterNode = createNode(GROUP_TYPES.WATER,
                            Math.random() * width,
                            height - 30 + Math.random() * 20
                        );
                        nodes.push(waterNode);
                    }

                    presetParams.rain.waterLevel = height - 40;
                },
                update: () => {
                    frameCount++;

                    // Spawn rain drops
                    if (frameCount % Math.floor(10 / presetParams.rain.rainRate) === 0) {
                        const raindrop = createNode(GROUP_TYPES.RAIN,
                            Math.random() * width,
                            -10
                        );
                        raindrop.vy = 2 + Math.random();
                        nodes.push(raindrop);
                    }

                    // Update nodes
                    nodes.forEach((node, i) => {
                        if (node.type === GROUP_TYPES.RAIN) {
                            // Rain falls
                            node.vy += 0.3;
                            node.y += node.vy;

                            // Convert to water when hitting water level
                            if (node.y > presetParams.rain.waterLevel) {
                                node.type = GROUP_TYPES.WATER;
                                node.radius = 4;
                                node.mass = 1;
                                node.color = randomFromArray(presetParams.rain.colors.water);
                                node.vy = 0;

                                // Link to nearby water nodes (surface tension)
                                const nearbyWater = nodes.filter(n =>
                                    n.type === GROUP_TYPES.WATER &&
                                    n !== node &&
                                    dist(n, node) < 40
                                ).slice(0, 3);

                                nearbyWater.forEach(target => {
                                    links.push({ source: node, target, strength: 0.5, distance: 20 });
                                });

                                // Update water level
                                presetParams.rain.waterLevel = Math.max(
                                    height * 0.3,
                                    Math.min(...nodes.filter(n => n.type === GROUP_TYPES.WATER).map(n => n.y)) - 10
                                );
                            }

                            // Remove if out of bounds
                            if (node.y > height + 50) {
                                nodes.splice(i, 1);
                            }
                        } else if (node.type === GROUP_TYPES.WATER) {
                            // Water settles down
                            node.vy += 0.1;

                            // Keep water at bottom
                            if (node.y > height - 10) {
                                node.y = height - 10;
                                node.vy *= -0.3;
                            }
                        } else if (node.type === GROUP_TYPES.BOAT) {
                            // Boat repelled by water (buoyancy)
                            nodes.filter(n => n.type === GROUP_TYPES.WATER).forEach(water => {
                                const d = dist(node, water);
                                if (d < 60) {
                                    const force = (60 - d) * 0.05;
                                    const angle = Math.atan2(node.y - water.y, node.x - water.x);
                                    node.vx += Math.cos(angle) * force;
                                    node.vy += Math.sin(angle) * force;
                                }
                            });

                            // Gravity on boat
                            node.vy += 0.05;

                            // Keep boat on screen
                            if (node.y > height - 20) {
                                node.vy *= -0.3;
                            }
                        }
                    });
                },
                info: 'Rain falls and accumulates as water. Boat floats on surface.<br>üñ± Wheel: Control rain rate'
            },

            honey: {
                init: () => {
                    nodes = [];
                    links = [];

                    // Start with some honey blobs
                    for (let i = 0; i < 15; i++) {
                        nodes.push(createNode(GROUP_TYPES.HONEY_BLOB,
                            Math.random() * width,
                            Math.random() * height * 0.5
                        ));
                    }
                },
                update: () => {
                    nodes.forEach((node, i) => {
                        // Attract to mouse when close
                        const dMouse = Math.sqrt(
                            Math.pow(mousePos.x - node.x, 2) +
                            Math.pow(mousePos.y - node.y, 2)
                        );

                        if (dMouse < 120) {
                            const force = (120 - dMouse) * 0.0003;
                            const angle = Math.atan2(mousePos.y - node.y, mousePos.x - node.x);
                            node.vx += Math.cos(angle) * force;
                            node.vy += Math.sin(angle) * force;
                        }

                        // Viscous drag
                        node.vx *= (1 - presetParams.honey.viscosity);
                        node.vy *= (1 - presetParams.honey.viscosity);

                        // Gravity (dripping)
                        node.vy += 0.15;

                        // Update position
                        node.x += node.vx;
                        node.y += node.vy;

                        // Wrap around
                        if (node.y > height + 20) {
                            node.y = -20;
                            node.x = Math.random() * width;
                        }
                        if (node.x < -20) node.x = width + 20;
                        if (node.x > width + 20) node.x = -20;

                        // Merge with nearby blobs
                        nodes.forEach((other, j) => {
                            if (i !== j && dist(node, other) < presetParams.honey.mergeDistance) {
                                // Create temporary link for visual coalescing
                                if (!links.find(l =>
                                    (l.source === node && l.target === other) ||
                                    (l.source === other && l.target === node)
                                )) {
                                    links.push({ source: node, target: other, strength: 0.1, distance: 15 });

                                    // Remove link after a while
                                    setTimeout(() => {
                                        links = links.filter(l =>
                                            !((l.source === node && l.target === other) ||
                                              (l.source === other && l.target === node))
                                        );
                                    }, 1000);
                                }

                                // Pull together
                                const pullForce = 0.01;
                                const angle = Math.atan2(other.y - node.y, other.x - node.x);
                                node.vx += Math.cos(angle) * pullForce;
                                node.vy += Math.sin(angle) * pullForce;
                            }
                        });
                    });
                },
                info: 'Viscous honey blobs coalesce and drip.<br>üñ± Mouse: Attract nearby blobs'
            },

            galaxy: {
                init: () => {
                    nodes = [];
                    links = [];

                    // Central massive nodes
                    const center1 = createNode(GROUP_TYPES.GALAXY_CENTER, width / 2, height / 2);
                    nodes.push(center1);

                    // Orbiting particles
                    for (let i = 0; i < 40; i++) {
                        const angle = (i / 40) * Math.PI * 2;
                        const radius = 50 + Math.random() * 80;
                        const orbiter = createNode(GROUP_TYPES.GALAXY_ORBITER,
                            center1.x + Math.cos(angle) * radius,
                            center1.y + Math.sin(angle) * radius
                        );

                        // Initial orbital velocity
                        const speed = 0.5 + Math.random() * 0.5;
                        orbiter.vx = -Math.sin(angle) * speed;
                        orbiter.vy = Math.cos(angle) * speed;

                        nodes.push(orbiter);
                    }
                },
                update: () => {
                    const centers = nodes.filter(n => n.type === GROUP_TYPES.GALAXY_CENTER);

                    nodes.forEach(node => {
                        if (node.type === GROUP_TYPES.GALAXY_ORBITER) {
                            // Orbital mechanics - attracted to center
                            centers.forEach(center => {
                                const dx = center.x - node.x;
                                const dy = center.y - node.y;
                                const d = Math.sqrt(dx * dx + dy * dy);

                                if (d > 0) {
                                    const force = (center.mass * presetParams.galaxy.orbitalStrength) / (d * d);
                                    node.vx += (dx / d) * force;
                                    node.vy += (dy / d) * force;
                                }
                            });

                            // Update position
                            node.x += node.vx;
                            node.y += node.vy;

                            // Slight drag
                            node.vx *= 0.99;
                            node.vy *= 0.99;

                            // Wrap around
                            if (node.x < 0) node.x = width;
                            if (node.x > width) node.x = 0;
                            if (node.y < 0) node.y = height;
                            if (node.y > height) node.y = 0;
                        }
                    });
                },
                info: 'Particles orbit central mass.<br>üñ± Drag: Move the center'
            },

            chaos: {
                init: () => {
                    nodes = [];
                    links = [];

                    for (let i = 0; i < 25; i++) {
                        const particle = createNode(GROUP_TYPES.CHAOS_PARTICLE,
                            Math.random() * width,
                            Math.random() * height
                        );
                        particle.vx = (Math.random() - 0.5) * 4;
                        particle.vy = (Math.random() - 0.5) * 4;
                        nodes.push(particle);
                    }
                },
                update: () => {
                    nodes.forEach((node, i) => {
                        // Random force bursts
                        if (Math.random() < 0.02) {
                            node.vx += (Math.random() - 0.5) * 2;
                            node.vy += (Math.random() - 0.5) * 2;
                        }

                        // Update position
                        node.x += node.vx;
                        node.y += node.vy;

                        // Bounce off walls
                        if (node.x < node.radius || node.x > width - node.radius) {
                            node.vx *= -0.9;
                            node.x = Math.max(node.radius, Math.min(width - node.radius, node.x));
                        }
                        if (node.y < node.radius || node.y > height - node.radius) {
                            node.vy *= -0.9;
                            node.y = Math.max(node.radius, Math.min(height - node.radius, node.y));
                        }

                        // Slight drag
                        node.vx *= 0.98;
                        node.vy *= 0.98;

                        // Random splitting
                        if (Math.random() < presetParams.chaos.splitChance && nodes.length < 50) {
                            const newParticle = createNode(GROUP_TYPES.CHAOS_PARTICLE,
                                node.x + (Math.random() - 0.5) * 10,
                                node.y + (Math.random() - 0.5) * 10
                            );
                            newParticle.vx = node.vx + (Math.random() - 0.5) * 2;
                            newParticle.vy = node.vy + (Math.random() - 0.5) * 2;
                            newParticle.radius = node.radius * 0.8;
                            node.radius *= 0.8;
                            nodes.push(newParticle);
                        }

                        // Random merging
                        nodes.forEach((other, j) => {
                            if (i < j && dist(node, other) < 15 && Math.random() < presetParams.chaos.mergeChance) {
                                // Merge into first node
                                node.radius = Math.sqrt(node.radius * node.radius + other.radius * other.radius);
                                node.vx = (node.vx + other.vx) / 2;
                                node.vy = (node.vy + other.vy) / 2;
                                nodes.splice(j, 1);
                            }
                        });
                    });
                },
                info: 'Chaotic particles split and merge randomly.<br>üñ± Click: Add energy burst'
            }
        };

        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // Render function
        function render() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(245, 245, 245, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw links
            ctx.lineWidth = 2;
            links.forEach(link => {
                const source = link.source;
                const target = link.target;

                ctx.strokeStyle = source.color + '40';
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius
                );
                gradient.addColorStop(0, node.color + 'dd');
                gradient.addColorStop(1, node.color + '66');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = node.color + '99';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Animation loop
        function tick() {
            if (!paused && currentPreset) {
                presets[currentPreset].update();
            }
            render();
            requestAnimationFrame(tick);
        }

        // Mouse interactions
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find node at position
            dragNode = nodes.find(node => dist(node, {x, y}) < node.radius + 5);

            // Chaos mode - add energy burst on click
            if (!dragNode && currentPreset === 'chaos' && e.button === 0) {
                nodes.forEach(node => {
                    const d = dist(node, {x, y});
                    if (d < 80) {
                        const force = (80 - d) * 0.1;
                        const angle = Math.atan2(node.y - y, node.x - x);
                        node.vx += Math.cos(angle) * force;
                        node.vy += Math.sin(angle) * force;
                    }
                });
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;

            if (dragNode && !dragNode.fixed) {
                dragNode.x = mousePos.x;
                dragNode.y = mousePos.y;
                dragNode.vx = 0;
                dragNode.vy = 0;
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragNode = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            if (currentPreset === 'rain') {
                // Control rain rate
                const delta = e.deltaY > 0 ? -0.5 : 0.5;
                presetParams.rain.rainRate = Math.max(0.5, Math.min(10, presetParams.rain.rainRate + delta));
            } else if (currentPreset === 'honey') {
                // Control viscosity
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                presetParams.honey.viscosity = Math.max(0.5, Math.min(0.98, presetParams.honey.viscosity + delta));
            } else if (currentPreset === 'galaxy') {
                // Control orbital strength
                const delta = e.deltaY > 0 ? -0.002 : 0.002;
                presetParams.galaxy.orbitalStrength = Math.max(0.005, Math.min(0.05, presetParams.galaxy.orbitalStrength + delta));
            }
        });

        // Keyboard interactions
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                paused = !paused;
            }
        });

        // Preset selection
        document.querySelectorAll('.preset').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPreset = btn.dataset.preset;
                frameCount = 0;
                presets[currentPreset].init();
                document.getElementById('preset-info').innerHTML = presets[currentPreset].info;
                document.getElementById('info-text').innerHTML = presets[currentPreset].info;
            });
        });

        // Fullscreen toggle
        document.getElementById('fullscreen-toggle').addEventListener('click', () => {
            container.classList.toggle('fullscreen');
            setTimeout(() => {
                width = window.innerWidth;
                height = container.classList.contains('fullscreen') ? window.innerHeight : 300;
                canvas.width = width;
                canvas.height = height;
                if (currentPreset) {
                    presets[currentPreset].init();
                }
            }, 50);
        });

        // Toggle controls
        document.getElementById('toggle-controls').addEventListener('click', (e) => {
            const controls = document.getElementById('controls');
            controls.classList.toggle('hidden');
            e.target.textContent = controls.classList.contains('hidden') ? 'Show Controls' : 'Hide Controls';
        });

        // Window resize
        window.addEventListener('resize', () => {
            if (!container.classList.contains('fullscreen')) {
                width = window.innerWidth;
                canvas.width = width;
                if (currentPreset) {
                    presets[currentPreset].init();
                }
            }
        });

        // Initialize with rain
        currentPreset = 'rain';
        presets.rain.init();
        document.querySelector('[data-preset="rain"]').classList.add('active');
        document.getElementById('preset-info').innerHTML = presets.rain.info;
        document.getElementById('info-text').innerHTML = presets.rain.info;
        tick();
    </script>
</body>
</html>
